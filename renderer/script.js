// Configuration object defining sections, subsections, and their descriptions
const sectionsConfig = {
  'main': {
    title: 'Graphics Pipeline',
    description: 'Click on a step to learn more about it.',
    sections: {
      'input': {
        title: 'Input',
        description: 'The input step handles the format and structure of data coming into the pipeline, including meshes, lights, and camera information.',
        subsections: {
          'mesh': 'Meshes are the geometric data that define the shape of objects in the scene, made up of vertices and edges.',
          'camera': 'The camera defines the view in the scene, determining the projection of 3D objects onto the 2D screen.',
          'lighting': 'Lighting defines how objects are illuminated, including light positions, colors, and types like directional or point lights.'
        }
      },
      'vertex-processing': {
        title: 'Vertex Processing',
        description: 'In the vertex processing stage, each vertex is processed by a vertex shader, transforming it from object space to clip space.'
      },
      'primitive-assembly': {
        title: 'Primitive Assembly',
        description: 'Primitive assembly gathers vertices into geometric shapes like triangles or lines and prepares them for rasterization.'
      },
      'rasterization': {
        title: 'Rasterization',
        description: 'Rasterization converts geometric primitives into pixel fragments to be processed by the fragment shader.'
      },
      'fragment-processing': {
        title: 'Fragment Processing',
        description: 'Fragment processing handles each pixel fragment generated by rasterization, determining color and depth values.'
      },
      'output-merging': {
        title: 'Output Merging',
        description: 'The output merging stage combines processed fragments, applying depth, stencil, and blending to generate the final image.'
      }
    }
  }
};

// Navigation stack to track the hierarchy
let navigationStack = ['main'];  // Start with 'main' in the stack

// Function to display a section or subsection based on navigation stack
function updateDisplay() {
  const currentSectionKey = navigationStack[navigationStack.length - 1];
  let currentSection = sectionsConfig.main;

  // Traverse the navigation stack to find the current section/subsection
  for (let i = 1; i < navigationStack.length; i++) {
    const key = navigationStack[i];
    if (currentSection.sections && currentSection.sections[key]) {
      currentSection = currentSection.sections[key];
    } else if (currentSection.subsections && currentSection.subsections[key]) {
      currentSection = { title: capitalizeFirstLetter(key), description: currentSection.subsections[key] };
    }
  }

  // Update description
  document.getElementById('current-title').innerText = currentSection.title;
  document.getElementById('step-description').innerText = currentSection.description;

  // Clear sections and subsections
  document.getElementById('section-list').innerHTML = '';
  document.getElementById('input-subsections').innerHTML = '';
  document.getElementById('back-button').classList.add('hidden');

  // If we're at the 'main' section, display all the main sections
  if (currentSectionKey === 'main') {
    renderMainSections(sectionsConfig.main.sections);
  } 
  // If we're at a section with subsections, render them
  else if (currentSection.subsections) {
    renderSubsections(currentSection.subsections);
    document.getElementById('back-button').classList.remove('hidden');
  } 
  // If we're at a final section without subsections, just show the description
  else {
    document.getElementById('back-button').classList.remove('hidden');
  }

  // Update options and content dynamically based on the current section
  updateOptions(currentSectionKey);
  updateContent(currentSectionKey);
}

// Render the main sections
function renderMainSections(sections) {
  const sectionList = document.getElementById('section-list');
  for (const sectionKey in sections) {
    const section = sections[sectionKey];
    const sectionElement = document.createElement('div');
    sectionElement.className = 'pipeline-step';
    sectionElement.innerText = section.title;
    sectionElement.onclick = () => navigateTo(sectionKey);
    sectionList.appendChild(sectionElement);
  }
}

// Render the subsections for a given section
function renderSubsections(subsections) {
  const subsectionList = document.getElementById('input-subsections');
  for (const subsectionKey in subsections) {
    const subsectionElement = document.createElement('div');
    subsectionElement.className = 'subsection';
    subsectionElement.innerText = capitalizeFirstLetter(subsectionKey);
    subsectionElement.onclick = () => navigateTo(subsectionKey);
    subsectionList.appendChild(subsectionElement);
  }
}

// Function to navigate to a section or subsection
function navigateTo(section) {
  navigationStack.push(section);
  updateDisplay();
}

// Function to go back to the previous section in the hierarchy
function goBack() {
  if (navigationStack.length > 1) {
    navigationStack.pop();  // Remove the current section
    updateDisplay();
  }
}

// Utility to capitalize first letter of a string
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// Function to update the options dynamically
function updateOptions(currentSectionKey) {
  const optionsContainer = document.getElementById('options');
  optionsContainer.innerHTML = '<h2>Options</h2>';  // Reset the options section

  if (currentSectionKey === 'mesh') {
    // Add a drop-down for Mesh section
    const select = document.createElement('select');
    select.id = 'mesh-selection';
    
    const cubeOption = document.createElement('option');
    cubeOption.value = 'cube.obj';
    cubeOption.innerText = 'cube.obj';
    
    const teapotOption = document.createElement('option');
    teapotOption.value = 'teapot.obj';
    teapotOption.innerText = 'teapot.obj';
    
    select.appendChild(cubeOption);
    select.appendChild(teapotOption);

    const label = document.createElement('label');
    label.innerText = 'Select Mesh Object: ';
    label.htmlFor = 'mesh-selection';
    
    optionsContainer.appendChild(label);
    optionsContainer.appendChild(select);
  }
}

// Function to update the content dynamically (dummy function for now)
function updateContent(currentSectionKey) {
  const contentContainer = document.getElementById('content');
  const contentTitle = document.getElementById('content-title');
  
  // Just updating the content title based on the current section
  if (currentSectionKey === 'mesh') {
    contentTitle.innerText = 'Mesh Visual Content';
  } else {
    contentTitle.innerText = 'Visual Content';
  }
}

// Initial load display
updateDisplay();
